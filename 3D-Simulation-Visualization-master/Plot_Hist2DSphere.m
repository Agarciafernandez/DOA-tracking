function varargout = Plot_Hist2DSphere(vPix, varargin)
% PLOT_HIST2DSPHERE is derived from the HP3D function, written by 
%                   Lee Samuel Finn and Matthew Kinsey (Copyright 2010-2011
%                   Lee Samuel Finn) and included in their MEALPix package.
%                   hp3d.m copyright information:  
%                   Authors: Lee Samuel Finn, Matthew Kinsey
%               $Id: hp3d.m 5795 2011-02-20 04:01:32Z lsf@GRAVITY.PSU.EDU $
%                   Copyright 2010-2011 by Lee Samuel Finn. 
%                   
%                   The primary difference is that our function plots a  
%                   high-relief HEALPix histogram on the unit sphere, as 
%                   opposed to the plot as prescribed by Finn and Kinsey.
%
% 
% Plot_Hist2DSphere(vPix,'Param1',Value1,'Param2',Value2,...);
%
% Required Inputs
% vPix   vector of values at HEALPix pixels, generated by Hist2DSphere.m
%
% Optional Inputs ???
% 'nest'     nest indexing (true | {false})???
%
% Requires corners, nPix2nSide
%
%%
% Note to user:
% Plot_Hist2DSphere is computationally intensive, and can take several 
% seconds, depending on processor speed.  The default number of HEALPix pixels, 
% nPix, (as a function of the number of sides, nSide, in the HEALPix 
% tesselation) is set to, nPix=192, which corresponds to nSide=2^2, to 
% facilitate speed of computation, but we suggest increasing it to at least 
% nPix=768, which corresponds to nSide=2^3.
%
%%
% Examples of correct usage:
%
% n=2^12; 
% nSide=2^3;
% nPix= nSide2nPix(nSide);
% kappa = 4.2;
% gamm = -3.5; 
% Mu=[0 0 1];
%
% Y =Random_FB4(kappa,gamm,Mu,n);
%
% hY = Hist2DSphere(Y,nPix); 
%
% Examples of correct function construction: 
% Plot_Hist2DSphere(hY,'nest',true) 
% Plot_Hist2DSphere(hY)
%
% vPix=abs(Ycx(:,M)).^2; vPix=hY; % this is where it 1st differs from HP3D
%%
%
% Authors: Gy.Terdik, B.Wainwright
%
% Copyright 2018 Gy.Terdik
%
% Licensed under the Apache License, Version 2.0 (the "License");
% you may not use this file except in compliance with the License.
% You may obtain a copy of the License at
%
% http://www.apache.org/licenses/LICENSE-2.0
%
% Unless required by applicable law or agreed to in writing, software
% distributed under the License is distributed on an "AS IS" BASIS,
% WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
% See the License for the specific language governing permissions and
% limitations under the License.
%
%% Parse and validate input
p = inputParser;
p.addRequired('vPix',@qVPix);
p.addParameter('nest',false,@(x)(isscalar(x) && islogical(x)));

p.parse(vPix,varargin{:});
% nest = p.Results.nest;

nSide = nPix2nSide(numel(vPix));
%%
vPix = reshape(1+vPix,[],1); % start from  1 

%% Get pixel corners c = corners(nSide);
cegy = corners(nSide,'nest',false);
c= cellfun(@times,num2cell(vPix'),cegy,'UniformOutput',false);
cn1=cell(size(c));
cn2=cell(size(c));
cn3=cell(size(c));
cn4=cell(size(c));
for k=1:length(c)
    cn1{k}= horzcat(c{k}(:,2),c{k}(:,3),cegy{k}(:,3),cegy{k}(:,2));
    cn2{k}= horzcat(c{k}(:,1),c{k}(:,4),cegy{k}(:,4),cegy{k}(:,1));
    cn3{k}= horzcat(c{k}(:,1),c{k}(:,2),cegy{k}(:,2),cegy{k}(:,1));
    cn4{k}= horzcat(c{k}(:,3),c{k}(:,4),cegy{k}(:,4),cegy{k}(:,3));
end

%% Plot patches
patchPlot = @(cn,v)(...
    patch(cn(1,:),cn(2,:),cn(3,:),v,'EdgeColor','none','FaceColor','flat'));

hold on
h  = cellfun(patchPlot,c,num2cell(reshape(vPix,1,[])),'UniformOutput',false);
h1 = cellfun(patchPlot,cn1,num2cell(reshape(vPix,1,[])),'UniformOutput',false);
h2 = cellfun(patchPlot,cn2,num2cell(reshape(vPix,1,[])),'UniformOutput',false);
h3 = cellfun(patchPlot,cn3,num2cell(reshape(vPix,1,[])),'UniformOutput',false);
h4 = cellfun(patchPlot,cn4,num2cell(reshape(vPix,1,[])),'UniformOutput',false);
grid on
hold off
%% figure prop
view(3);
colormap(jet(1024));
colorbar
camlight left
camlight right
lighting phong
A=max(1.5,max(vPix(:)));
axis([-A A -A A -A A])
%%
if 1 == nargout
    varargout{1} = h;
end
return

function tf = qVPix(vPix)
% QVPIX validate vPix
%
% vPix is a numeric vector of length 12*k^2 for k a non-negative integer
% power of 2

tf = isnumeric(vPix) && max(size(vPix)) == numel(vPix);

if tf
    nSide = floor(sqrt(numel(vPix)/12));
    ln2 = log2(nSide);
    tf = tf && ...
        numel(vPix) == 12*nSide^2 && ...
        floor(ln2) == ln2;
end
return